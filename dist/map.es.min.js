/**
 * rubico v1.9.7
 * https://github.com/a-synchronous/rubico
 * (c) 2019-2021 Richard Tong
 * rubico may be freely distributed under the MIT license.
 */
const symbolIterator=Symbol.iterator,MappingIterator=(r,n)=>({toString:()=>"[object MappingIterator]",[symbolIterator](){return this},next(){const t=r.next();return t.done?t:{value:n(t.value),done:!1}}}),NextIteration=r=>({value:r,done:!1}),isPromise=r=>null!=r&&"function"==typeof r.then,symbolAsyncIterator=Symbol.asyncIterator,MappingAsyncIterator=(r,n)=>({[symbolAsyncIterator](){return this},async next(){const t=await r.next();if(t.done)return t;const e=n(t.value);return isPromise(e)?e.then(NextIteration):{value:e,done:!1}}}),__=Symbol.for("placeholder"),curry2ResolveArg0=(r,n)=>function(t){return r(t,n)},curry2ResolveArg1=(r,n)=>function(t){return r(n,t)},curry2=function(r,n,t){return n==__?curry2ResolveArg0(r,t):curry2ResolveArg1(r,n)},isArray=Array.isArray,isObject=r=>{if(null==r)return!1;const n=typeof r;return"object"==n||"function"==n},objectProto=Object.prototype,nativeObjectToString=objectProto.toString,objectToString=r=>nativeObjectToString.call(r),generatorFunctionTag="[object GeneratorFunction]",isGeneratorFunction=r=>objectToString(r)==generatorFunctionTag,asyncGeneratorFunctionTag="[object AsyncGeneratorFunction]",isAsyncGeneratorFunction=r=>objectToString(r)==asyncGeneratorFunctionTag,promiseAll=Promise.all.bind(Promise),arrayMap=function(r,n){const t=r.length,e=Array(t);let o=-1,c=!1;for(;++o<t;){const t=n(r[o],o,r);isPromise(t)&&(c=!0),e[o]=t}return c?promiseAll(e):e},generatorFunctionMap=(r,n)=>function*(...t){for(const e of r(...t))yield n(e)},asyncGeneratorFunctionMap=function(r,n){return async function*(...t){for await(const e of r(...t))yield n(e)}},reducerMap=(r,n)=>function(t,e){const o=n(e);return isPromise(o)?o.then(curry2(r,t,__)):r(t,o)},curry3ResolveArg0=(r,n,t)=>function(e){return r(e,n,t)},curry3ResolveArg1=(r,n,t)=>function(e){return r(n,e,t)},curry3ResolveArg2=(r,n,t)=>function(e){return r(n,t,e)},curry3=function(r,n,t,e){return n==__?curry3ResolveArg0(r,t,e):t==__?curry3ResolveArg1(r,n,e):curry3ResolveArg2(r,n,t)},callPropUnary=(r,n,t)=>r[n](t),stringMap=function(r,n){const t=arrayMap(r,n);return isPromise(t)?t.then(curry3(callPropUnary,__,"join","")):t.join("")},always=r=>function(){return r},setMap=function(r,n){const t=new Set,e=[];for(const o of r){const c=n(o,o,r);isPromise(c)?e.push(c.then(curry3(callPropUnary,t,"add",__))):t.add(c)}return 0==e.length?t:promiseAll(e).then(always(t))},curry4ResolveArg0=(r,n,t,e)=>function(o){return r(o,n,t,e)},curry4ResolveArg1=(r,n,t,e)=>function(o){return r(n,o,t,e)},curry4ResolveArg2=(r,n,t,e)=>function(o){return r(n,t,o,e)},curry4ResolveArg3=(r,n,t,e)=>function(o){return r(n,t,e,o)},curry4=function(r,n,t,e,o){return n==__?curry4ResolveArg0(r,t,e,o):t==__?curry4ResolveArg1(r,n,e,o):e==__?curry4ResolveArg2(r,n,t,o):curry4ResolveArg3(r,n,t,e)},callPropBinary=(r,n,t,e)=>r[n](t,e),mapMap=function(r,n){const t=new Map,e=[];for(const[o,c]of r){const a=n(c,o,r);isPromise(a)?e.push(a.then(curry4(callPropBinary,t,"set",o,__))):t.set(o,a)}return 0==e.length?t:promiseAll(e).then(always(t))},promiseObjectAllExecutor=r=>function(n){const t={};let e=0;for(const o in r){const c=r[o];isPromise(c)?(e+=1,c.then((r=>function(o){t[r]=o,e-=1,0==e&&n(t)})(o))):t[o]=c}0==e&&n(t)},promiseObjectAll=r=>new Promise(promiseObjectAllExecutor(r)),objectMap=function(r,n){const t={};let e=!1;for(const o in r){const c=n(r[o],o,r);isPromise(c)&&(e=!0),t[o]=c}return e?promiseObjectAll(t):t},funcConcat=(r,n)=>function(...t){const e=r(...t);return isPromise(e)?e.then(n):n(e)},objectSet=function(r,n,t){return r[n]=t,r},arrayMapSeriesAsync=async function(r,n,t,e){const o=r.length;for(;++e<o;){const o=n(r[e]);t[e]=isPromise(o)?await o:o}return t},arrayMapSeries=function(r,n){const t=r.length,e=Array(t);let o=-1;for(;++o<t;){const t=n(r[o]);if(isPromise(t))return t.then(funcConcat(curry3(objectSet,e,o,__),curry4(arrayMapSeriesAsync,r,n,__,o)));e[o]=t}return e},tapSync=r=>function(...n){return r(...n),n[0]},promiseRace=Promise.race.bind(Promise),arrayMapPoolAsync=async function(r,n,t,e,o,c){const a=r.length;for(;++o<a;){c.size>=t&&await promiseRace(c);const a=n(r[o]);if(isPromise(a)){const r=a.then(tapSync((()=>c.delete(r))));c.add(r),e[o]=r}else e[o]=a}return promiseAll(e)},arrayMapPool=function(r,n,t){const e=r.length,o=Array(e);let c=-1;for(;++c<e;){const e=n(r[c]);if(isPromise(e)){const a=new Set,s=e.then(tapSync((()=>a.delete(s))));return a.add(s),o[c]=s,arrayMapPoolAsync(r,n,t,o,c,a)}o[c]=e}return o},arrayMapWithIndex=function(r,n){const t=r.length,e=Array(t);let o=-1,c=!1;for(;++o<t;){const t=n(r[o],o,r);isPromise(t)&&(c=!0),e[o]=t}return c?promiseAll(e):e},hasOwnProperty=Object.prototype.hasOwnProperty,hasOwn=(r,n)=>hasOwnProperty.call(r,n),objectMapOwn=function(r,n){const t={};let e=!1;for(const o in r)if(hasOwn(r,o)){const c=n(r[o]);isPromise(c)&&(e=!0),t[o]=c}return e?promiseObjectAll(t):t},_curryArity=(r,n,t)=>function(...e){const o=t.length,c=e.length,a=[];let s=-1,i=-1,u=0;for(;++s<o;){const o=t[s];if(o==__&&(i+=1)<c){const r=e[i];r==__&&(u+=1),a.push(r)}else a.push(o);if(a.length==r)return 0==u?n(...a):curryArity(r,n,a)}for(;++i<c;){const t=e[i];if(t==__&&(u+=1),a.push(t),a.length==r)return 0==u?n(...a):curryArity(r,n,a)}return curryArity(r,n,a)},curryArity=function(r,n,t){const e=t.length;if(e<r)return _curryArity(r,n,t);let o=-1;for(;++o<e;){if(t[o]==__)return _curryArity(r,n,t)}return n(...t)},spread2=r=>function([n,t]){return r(n,t)},objectMapEntries=function(r,n){const t={},e=[];for(const o in r){const c=n([o,r[o]]);isPromise(c)?e.push(c.then(spread2(curryArity(3,objectSet,[t])))):t[c[0]]=c[1]}return 0==e.length?t:promiseAll(e).then(always(t))},mapSet=function(r,n,t){return r.set(n,t)},mapMapEntriesForEachCallback=(r,n,t)=>function(e,o){const c=r([o,e]);isPromise(c)?t.push(c.then(spread2(curryArity(3,mapSet,[n])))):n.set(c[0],c[1])},mapMapEntries=function(r,n){const t=new Map,e=[];return r.forEach(mapMapEntriesForEachCallback(n,t,e)),0==e.length?t:promiseAll(e).then(always(t))},_map=function(r,n){return isArray(r)?arrayMap(r,n):"function"==typeof r?isGeneratorFunction(r)?generatorFunctionMap(r,n):isAsyncGeneratorFunction(r)?asyncGeneratorFunctionMap(r,n):reducerMap(r,n):null==r?r:"function"==typeof r.then?r.then(n):"function"==typeof r.map?r.map(n):"string"==typeof r||r.constructor==String?stringMap(r,n):r.constructor==Set?setMap(r,n):r.constructor==Map?mapMap(r,n):"function"==typeof r[symbolIterator]?MappingIterator(r[symbolIterator](),n):"function"==typeof r[symbolAsyncIterator]?MappingAsyncIterator(r[symbolAsyncIterator](),n):r.constructor==Object?objectMap(r,n):n(r)},map=(...r)=>{const n=r.pop();return r.length>0?_map(r[0],n):curry2(_map,__,n)};map.entries=function(r){return function(n){if(null==n)throw new TypeError("value is not an Object or Map");if(n.constructor==Object)return objectMapEntries(n,r);if(n.constructor==Map)return mapMapEntries(n,r);throw new TypeError("value is not an Object or Map")}},map.series=r=>function(n){if(isArray(n))return arrayMapSeries(n,r);throw new TypeError(`${n} is not an Array`)},map.pool=(r,n)=>function(t){if(isArray(t))return arrayMapPool(t,n,r);throw new TypeError(`${t} is not an Array`)},map.withIndex=r=>function(n){if(isArray(n))return arrayMapWithIndex(n,r);throw new TypeError(`${n} is not an Array`)},map.own=r=>function(n){if(isObject(n)&&!isArray(n))return objectMapOwn(n,r);throw new TypeError(`${n} is not an Object`)};export default map;
