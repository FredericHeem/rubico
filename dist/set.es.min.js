/**
 * rubico v1.9.6
 * https://github.com/a-synchronous/rubico
 * (c) 2019-2021 Richard Tong
 * rubico may be freely distributed under the MIT license.
 */
const isPromise=r=>null!=r&&"function"==typeof r.then,isArray=Array.isArray,isObject=r=>{if(null==r)return!1;const e=typeof r;return"object"==e||"function"==e},memoizeCappedUnary=function(r,e){const t=new Map,n=function(n){if(t.has(n))return t.get(n);const s=r(n);return t.set(n,s),t.size>e&&t.clear(),s};return n.cache=t,n},pathDelimiters=/[.|[|\]]+/,parsePropertyPath=function(r){const e=r.length-1,t="["==r[0],n="]"==r[e];return t&&n?r.slice(1,e).split(pathDelimiters):t?r.slice(1).split(pathDelimiters):n?r.slice(0,e).split(pathDelimiters):r.split(pathDelimiters)},memoizedCappedParsePropertyPath=memoizeCappedUnary(parsePropertyPath,500),propertyPathToArray=r=>isArray(r)?r:"string"==typeof r?memoizedCappedParsePropertyPath(r):[r],setByPath=function(r,e,t){if(!isObject(r))return r;const n=propertyPathToArray(t),s=n.length,o=s-1,i={...r};let c=i,a=-1;for(;++a<s;){const r=n[a];if(a==o)c[r]=e;else{const e=c[r],t=isArray(e)?e.slice():{...e};c[r]=t,c=t}}return i},__=Symbol.for("placeholder"),curry3ResolveArg0=(r,e,t)=>function(n){return r(n,e,t)},curry3ResolveArg1=(r,e,t)=>function(n){return r(e,n,t)},curry3ResolveArg2=(r,e,t)=>function(n){return r(e,t,n)},curry3=function(r,e,t,n){return e==__?curry3ResolveArg0(r,t,n):t==__?curry3ResolveArg1(r,e,n):curry3ResolveArg2(r,e,t)},set=(r,e)=>function(t){if("function"==typeof e){const c=e(t);return isPromise(c)?c.then((n=setByPath,o=__,i=r,(s=t)==__?curry3ResolveArg0(n,o,i):o==__?curry3ResolveArg1(n,s,i):curry3ResolveArg2(n,s,o))):setByPath(t,c,r)}var n,s,o,i;return setByPath(t,e,r)};export default set;
